<speak version="1.0" xml:lang="ja-JP">
    <voice name="ja-JP-NanamiNeural">
  
    前回は、プレイヤーを画面の下で左右に動かすところまで完成しましたね。  
    今回は、空から「落ちてくる物」を作っていきましょう。  
  
    テーマは、「落下物を一定間隔で生成して、下に落とす」です。  
    これができると、ゲームの動きが一気に生き生きしてきます。  
  
    <break time="1s"/>
  
    まず、落下物を表すための変数を作ります。  
    落下物は1つだけでなく、次々と出てくるので、  
    複数をまとめて管理できる「リスト」を使います。  
  
    リストとは、いくつものデータをまとめて扱える入れ物のようなものです。  
    たとえば、空のリストを作っておいて、  
    そこに新しい落下物の情報を追加していく、というイメージです。  
  
    <break time="3s"/>
  
    では、1つの落下物の情報を考えてみましょう。  
    落下物には、横位置、縦位置、そして落ちるスピードがあります。  
    横の位置はランダムに、縦は0、スピードは1から3くらいに設定します。  
    これを「辞書」と呼ばれる形でまとめておくと便利です。  
  
    具体的な書き方は資料を見ながら確認してください。  
    「新しいオブジェクトを作り、リストに追加する」という仕組みになっています。  
  
    <break time="3s"/>
  
    では、ここで実際に手を動かしてみましょう。  
    update関数の中に、一定間隔で新しい落下物を追加する処理を書いてください。  
    「60フレームに1回追加する」といった形でタイマーを使います。  
  
    フレームカウンターを1ずつ増やしていき、  
    一定のタイミングでリストに落下物を追加するようにしましょう。  
    どのように書くかは、授業資料のサンプルを参考にしてください。  
  
    <break time="6s"/>
  
    次に、落下物を動かす処理を作ります。  
    update関数の中で、リストに入っているすべての落下物を、  
    毎フレーム少しずつ下に動かします。  
  
    ループを使って、落下物のy座標を「スピード分だけ増やす」処理を追加します。  
    さらに、画面の下まで落ちたものは削除しておきましょう。  
    この部分の書き方も、資料を見ながら進めてください。  
  
    <break time="5s"/>
  
    次に、draw関数で落下物を描きます。  
    リストの中身をひとつずつ取り出して、  
    円や四角の図形を描いていきます。  
    落下物の形や色は自由です。  
    丸いボールのようにしてもいいですし、四角いブロックでも構いません。  
  
    <break time="5s"/>
  
    では、一度実行してみましょう。  
    画面の上から、一定間隔でオブジェクトが落ちてくるはずです。  
    プレイヤーはまだ関係していませんが、  
    これでゲームの「世界」が少しずつ動き始めました。  
  
    <break time="3s"/>
  
    落ちるスピードが速すぎたり、数が多すぎたりした場合は、  
    生成間隔やスピードの値を調整してみましょう。  
    このバランスを変えるだけでも、  
    ゲームの印象が大きく変わります。  
  
    <break time="3s"/>
  
    では最後に、今回のポイントを整理します。  
    一、リストを使って複数の落下物を管理すること。  
    二、タイマーを使って一定間隔で追加すること。  
    三、画面の下まで落ちたら削除すること。  
  
    この3つができれば、ゲームの動きに命が吹き込まれます。  
  
    <break time="2s"/>
  
    次の動画では、プレイヤーと落下物がぶつかったときの「キャッチ判定」を実装します。  
    いよいよスコアが加算されて、ゲームらしくなっていきますよ。  
  
    </voice>
  </speak>
  