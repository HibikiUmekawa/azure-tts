<speak version="1.0" xml:lang="ja-JP">
    <voice name="ja-JP-NanamiNeural">
  
    前回は、空から落ちてくるオブジェクトを作って、  
    一定間隔で生成し、下に落とすところまで完成しましたね。  
    今回はいよいよ、「キャッチ判定」を実装していきます。  
  
    <break time="1s"/>
  
    キャッチ判定とは、落下物とプレイヤーがぶつかったときに、  
    「取った！」と判断する仕組みのことです。  
    これができると、スコアが加算され、ゲームとしての面白さが一気に増します。  
  
    <break time="2s"/>
  
    まずは考え方を整理しましょう。  
    プレイヤーは四角い形、落下物は丸や四角などの形で描かれています。  
    それぞれの位置を座標で管理しているので、  
    この「位置の重なり」を調べることで、当たったかどうかを判定できます。  
  
    <break time="2s"/>
  
    イメージとしてはこうです。  
    落下物の横の位置が、プレイヤーの幅の範囲に入っているか。  
    そして、落下物の縦の位置が、プレイヤーの高さに届いているか。  
    この2つが同時に成立していれば、「キャッチ成功」です。  
  
    <break time="3s"/>
  
    では、ここで実際に手を動かしてみましょう。  
    update関数の中で、落下物を動かしている部分のすぐ下に、  
    プレイヤーとの当たり判定を追加します。  
  
    もし当たったら、そのオブジェクトをリストから削除します。  
    つまり、「キャッチした＝もう落ちてこない」という処理です。  
    書き方の具体例は、授業資料を見ながら確認してください。  
  
    <break time="6s"/>
  
    さらに、スコアを加算しましょう。  
    ゲームの最初でスコアを0に設定しておき、  
    キャッチしたタイミングで1点追加します。  
    たとえば、「スコアを1増やす」という一文を当たり判定の中に入れればOKです。  
    これも資料のサンプルを参考にしてみてください。  
  
    <break time="4s"/>
  
    では、ここでまた実践タイムです。  
    update関数の中に、当たり判定とスコア加算を追加してみましょう。  
    そして、draw関数の中ではスコアを画面に表示します。  
    画面の左上に「SCORE」と表示して、  
    その横にスコアの値が出るようにしてみましょう。  
    コードは資料を見ながら書いてください。  
  
    <break time="6s"/>
  
    実行してみると、プレイヤーの上に落下物が当たるたびに、  
    スコアが1点ずつ増えていくはずです。  
    当たった瞬間に落下物が消えることも確認してみましょう。  
  
    <break time="3s"/>
  
    ここまでできたら、ゲームとしての基礎部分は完成です。  
    ただ落ちてくるだけの世界が、  
    「取る」「得点になる」というルールを持ったことで、  
    ぐっと面白く感じられるようになりましたね。  
  
    <break time="2s"/>
  
    では、ここで今日のポイントを整理します。  
    一、座標を使って当たり判定を行うこと。  
    二、キャッチしたオブジェクトを削除すること。  
    三、スコアを加算し、画面に表示すること。  
  
    この3つは、どんなゲームにも登場する、とても大切な仕組みです。  
  
    <break time="3s"/>
  
    次の動画では、このゲームに「ミス判定」と「ゲームオーバー処理」を加えて、  
    さらに完成度を高めていきます。  
    取れなかったら減点、3回ミスしたら終了、というルールを加えて、  
    ゲームとしての流れを完成させましょう。  
  
    </voice>
  </speak>
  